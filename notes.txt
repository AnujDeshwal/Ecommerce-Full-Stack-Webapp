topic: How to connect to the mongodb 
    simple run your compass and connect it with the localhost and then go to the vs code and run the code to connect the backend from mongodb in mongoose , where as soon as you will run post request in your database databse would be created with the provided name you have given in the url simple .
Model: model is a collection simple or a table you can say of a particular thing here it is of product .
Controller: controller is basically which control the model means will do all crud operation in the model   
Product.save is different from insert because if you will provide id to it so it will behave as update but if no id so it will work as normal insertion
topic: important about the exports. 
here like you are in the folder you have exports many thing like exports like exports.add=add 
, exports.sub = sub then at the file where you are using in that file you are importing them like 
const {add, sub} =  require('./routes/products) ; here by destructuring you have just separate add and sub while importing now you can directly use them . but if you will import like 
const temp = require('/routes/products') here it always come in a object so you can use them like 
temp.add and temp.sub 
topic:very important thing about the mongoose is that there is a thing in the like whatever you did write query like you applied find ,skip whatevery query you need some apply but it will be executed if you will apply .exec() after those query which will execute them in reality and amother important thing about :::CLONE: that if you execute a query you can not execute it again it will throw an error and if you want to run the same query again just clone it like in that same query whih was executed write this query.clone().exec() then it will execute again 
topic: one important thing about mongoose is that in it all queries are promises so if you want it to executed then other things should work so use await and in the await also use try catch to catch the error 
topic:whenever you are applying try can catch and then sending the error as response so that error does not go in response many times so just console.log it .
Topic : how api is working or connecting between frontend and backend 
so basically we are using api in the frontend by using fetch api so whatever they are doing is calling the api , and api has been made in the backend  and whatever request they are sending from the frontend while calling the api we are getting these request in the backend in our api , when they are sending something with the api call it is call post request , so if they are calling a api with post request so we must have that api with the post property in our backend so basically whatever data they send in the body of the request while calling the api so this can be fetched by the req.body in the backend ,and to make a api we need three things first is controller in whicch all query for database is mentioned , then model comes which is the schema of the api call basically for that api may be data would come from a tabel of collection of the database so first you have to make a collection or model in the database so to make this you have model file so run all query inside it you have controller and now you made the api but now connect it to the route folder in which url it will be shown then route folder comes in play and then if already mentioned on the url so go to the index.js and routes are made already over there where something already added in the base address . 
Topic:to check what is error 
go to inspect then go to network error it will show all api calls if you click on fetch/XHR then just check their status either 200 or 404 
Topic:another error is unexpected end of json so this means that he is trying to fetch json data but json data aa nahi paa raha from the backend so just go to network and see if any request is giving you 404 not found error 
Topic: we are making all table by seeing the all objects or collection present in the data.json which we took from the dummyjson may be 
Topic:error is this : Cast to ObjectId failed for value \"{\n  email: 'anujdeshwal95@gmail.com',\n  password: '@Deshwal95',\n  role: 'user',\n  addresses: [] , here problem is this that we are sending all informatio of user but it just requires objectid or userid jiska type objectid hoti hai english pado na cast to objectid failed for value means is url mai dekho kuch post ho raha hoga toh galat information bhej rahe ho , i got this error from the network portion of the inspect


Topic: how to use passportjs for authentication
do need of two things to install such as npm install passport express-session
-----------------------------------------Payment integration using stripe--------------------------
Topic: payment gateway integration using stripe 
first install striep using npm i --save stripe
payment process is complicated because security is the main concern here , here stripe is connected with the backend and stripe provides a secret key to the server through which payment will be processed and secret key is secured because it resides in the backend and of course backend is taken care by you so secret key is secured by you , frontend mai toh user dekh sakte hai but here backend mai sab kuch aap ke hath mai hai 
flow -> first of all stripe has its own server to process the payment 

ques: what is webhook?
note -> first of all webhook uses a key so when will you provide the end point to the webhook basically where stripe will send the result of your payment, so ye endpoint tab hi dena jab deploy kar dena because that url would be publicly exposed , and your localhost is not a url which can be accessed by anyone only you can access it so it could not be a endpoint but after deployment webhook mai jaa ke just change the end point and endpoint key us wakt hi generate hogi vo waali hi use karna and return url of payment in stripe will be vercel ki url jisme hamari webapp hai  
ans: basically webhook is nothing but a api which is made by you but it is exposed to public means that another server can call it which is configured to it , here in the stripe you make your payment done so after making the payment done whether that payment was completed or incomplete or any error so how then stripe server will communicate with you about that status of payment so then you make a api which is exposed to the public so that stripe can use that api to get use know the status of payment , so then we create a webhook in the stripe website webhook is a basically a url or api jisme stripe status of payment or other info bhej paye so then webhook , now if url stripe ko batana hai toh stripe bolta hai that aapko stripe ka cli use karna hoga usme then aap url wagera webhook ka de sakte ho so vo stripe ki website se pata chal jayega how to login to stripe cli and all that or just go to same project video and go to timeline 11:00. stripe login and direct to ek terminal mai karna and then teesri command aap doosre terminal mai karna .
// here importance of webhook dikhegi aapko because through webhook only stripe can communicate to our server that payment intent is successed and we passed the order id in the metadata of the paymentintent so that when webhook url would be called by the stripe so it will provide us that metadata then we will mark the paymentstatus to received of that order ,listene order success page is the one shown by us there is no guarantee that payment has been received but through the webhook it is guaranteed that payment is received .
Some additional thing in webhook is it generally gives error , then do this server.use('/webhook', express.raw({type: "*/*"})) , it means sirf is url mai express.raw lagao and webhook ko ye hi chahieye althrough webhook mai pehle se hi express.raw kuch hota hai but vo work nahi karta hai 
working flow::
first client make a request of payment , then this request goes to the backend basically because now backend will communicate to the stripe and basicallly we are using stripe so that koi bhi client hame bank account mai payment kar sake warna hame kya karna padta that is we would have to provide our account in our ecommerce website that if you want to purchase a product so first do payment in this account online then we will see whether you have done that payment or not then we will consider your buying legal , so this is not optimal approach , because user needs like something pop us in front of us and we just enter the amoont of payment and then that money should be debited from our account ,so basically stripe is just a intermediate node between us and bank account , so as soon as client make a payment request to the backend so then backend communicates with the stripe server and stripe then create a payment intent , and because of this payment intent a checkout page is opened where user enters its card details and now this all details will go the stripe with the cleint secret because although you have submitted the details but it could be fraud or something so initially a payment intent was created by the stripe is checked through cleint secret if stripe get the client secret then it further process the payment . So for better under standing to the coding with muhib integration with the stripe in doctor appointment app.
-------------which was giving me many error that add description , add customer name , address , because i was using test card number which was not of india so stripe was considering it a international payment so then customer aapko create karna padta but then i used this indian test card number : 4000003560000008 here you do need to add a customer jo payment karega . 








ques: how did we shift the local database to the remote database like mongodb atlas (you can go to the 11:12 timeline in the ecommerce webapp video )
very important when you connect to the mongoose or mongodb so it seeks for a url jaha tumhara database hai so there you have to provide a connection string when we use local database toh localhost:27071 use karlete hai but here doosra url chahiye becaus we are using cloud database so go to that cloud and connection string hogi vo laga do 
ans: here we did like first we we make the account in the mongodb atlas and create the project in it and during creating the  project we do give access the user who can access our database and also which ip address can access our database then our whole database was in our local database so we did like we ran a command called as mongodump which can create a dump folder consist of whole local data and we can send this dump data to a remote database here we will send it in the mongodb atlas a cloud database provider ,so first (mongodump --db ecommerce )was the command here we put the name of the database which should be copied only in the dump so that only will be sent over to remote database then in our project in the mongodb atlab go to database then go to command line tools there they have given a command (mongodb restore) copy full command and then put the password of the user which is allowed to access in the place of <password> this restore command will copy the full dump folder to the atlas databse now you can use cloud database easily 

-----------------Doing deployment------------------------
So when we do deployment , so first we make a build of frontend so before making it we do one thing that is jaha bhi http://localhost:8080 ye likha hai where our whole server is in local host and whole frontend it calling for this url only so we replace it with blank character now only / se shuru hote hai saare ke saare kuki jaha aap deploy karoge waha vo apna url dalenge then sabko / se shuru karenge,
lets see what is the whole scenerio of the deployment that is first of all in vercel your backend and frontend run in one port so what we do in our local pc that while making frontend we are making request on the backend like backend is running on port 8080 so i will make request to 8080 from the frontend so at this time our backend and frontend is on different port but then i did i replace all 
localhost:8080/ api call to just '/' because now our backend and frontend is on one port , i did this by making a build of a frontend by npm run build then paste this build in the backend then in the index.js server.use(express.static(path.resolve(__dirname,'build))) so that now it will provide frontend as a static file from the build , and now backend is on 8080 and in the frontend all api call / se start hai means relative to the current port which is now 8080 for the frontend so everything is few minutes ago frontend was on the 3000 so while making api call you had to specify localhost:8080 but now as they are in same port so no need of but take care of routing each url should be different, then vercel works like just make a repository in the github with that backend which has build and backend files then simply go to vercel open that repository and deploy it , vercel will give you a domain , sabse chota waala domain is permament., then in future whereever you will commit changes in that repository vercel willl automaically redeploy with new changes  and vercel.json file banani padti hai use dekhlena .
-----------------------------PORT_------------------------------------------
--------like you are in backend so ofcourse in app.listen you would have given the port number then whatever api you made there you do not need to specify like app.post("/webhook") no because it is already configured that in which whole thing is going on so just write /webhook it will be relative to the port but if you have to request to another port or url then you need to enter whole url correctly if you are just write /webhook means it is relative to your port only , so this will redirect to your port only in /webhook path not in another port 
----------------------------Sending Email-------------------------------------------------------------
here i used nodemailer , in nodemailer first install nodemailer then require it then you have to make transporter object which i have created in the index.js file basically this transporter object is for to configure your gmail because you can send a email from a gmail account to a gmail account , it means that it is not like you can send email to anyone through node no , here nodemailer is providing the servic to send mails without using the gmail app , but in the nodemailer you have to configure your gmail username ans password so that from the behalf of your gmail they will send the mail to other , now the password i mentioned like procces.env.MAIL_PASSWORD it is not my real password of gmail , it is the app password , now app password is something in your 2 step verification in the setting of your google account , there you can give a name like nodemailer which would contact them to send mail on the behalf of my gmail then they will provide a password for the nodemailer ,just put that password in that MAIL_PASSWORD variable so this will work also whenever nodemailer will try to contact to the gmail server so you can use this password which you got through the app password mechanism , remember there is a thing i used something like tls , this optionn is important 
//here we are generating a resetPasswordToken , this token will be made before hand of sending the mail to anyone so that when he will click on the link to reset the password so at time , he will come up with the same token which we generated beforehand so we will verify , it is because if anyone will get to know that in the url /auth/reset-password we can reset the password so any hacker would do it and reset the password so this is for authentication that you can only come on this url from our mail not from direct putting the url,

so basically for verification we were using the token , so here when user will click on the email link so how will user get token so that he will be verified through that token so here we are using concept of params , means when you are making a email sent request means sending the mail to the user gmail witht that reset password link so you are adding the token and email of that user to that link or url so that when user will click on that link so we will fetch the token and email from the url params then we will verify that user , but if someone will try to do /auth/reset-password and here no token and email is available in the params so simply we will reject it with error and if hacker will be smart and do like /auth/reset-password?token=38493heff&email=anujdeshwal95@gmail.com , here he tried random token but we are checking it with the token stored in the database , we stored it while generating it , sending token and email with the link was a good approach  to verify 